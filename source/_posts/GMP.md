---
title: GMP
date: 2023-03-22 22:15:43
tags: goroutine
categories: Golang
---

### 前言
我们都知道 **Golang** 的并发性能很高，得益于它优秀的 **GMP** 模型设计，那么 **GMP** 模型到底巧妙在哪了，这就是本文所要讨论的。
本篇文章的精华取自于[Golang深入理解GPM模型](https://www.bilibili.com/video/BV19r4y1w7Nx?p=18&spm_id_from=pageDriver&vd_source=dfeba0e84225bbb1159a33a311780697)。

### 历史
#### 单进程
在操作系统早期，系统只有单核，计算机执行任务是完全按编排的顺序执行，A任务执行完执行B任务，B任务执行完执行C任务；那么当B任务（其实也就是一个进程）阻塞了就只能一直等着。
#### 多进程
想象一下我们现在要写一个网络爬虫，爬取100个页面，每个页面服务器响应1s，整个过程下来100多s（处理数据，写到数据库等也需要时间）就没了，后来就出现了多进程/多线程技术，当一个任务在IO阻塞时，CPU会切换到其他任务执行，等到其他任务执行完再回来执行这个任务。相比于最开始性能提升了很多，CPU也不再空闲了，实现了所谓的“并发”，注意不是并行。
#### 多核多进程
随着硬件技术的发展，计算机进入了多核时代，多个CPU可以同时工作，此时才可以说是并行。问题又出现了，进程非常占用资源，进程之前的切换代价也很高，
1. 保存上下文：CPU寄存器，程序计数器，进程状态等
2. 加载新的上下文：把新的上下文加载到CPU寄存器，程序计数器的对应位置
3. 切换内存空间：进程之间的内存空间是独立的，因此切换进程的时候操作系统还需要切换进程的内存空间
4. 切换硬件上下文：如IO缓存、中断向量等
比较常规的做法是使用多线程技术，由于同一个进程里的所有线程都共享一个进程的内存空间、文件描述符、以及进程的全局变量等。线程切换时也只需要切换线程自己的上下文信息，不需要切换内存空间和其他进程的相关资源。
但是多线程同样带来了新的问题：由于在同一个进程内，共享了进程的全局变量和内存，为了保证数据安全多个线程竞争时要加锁，这种互斥行为带来的开销是非常大的。
#### 协程
由于线程和进程的调度都是由操作系统来调度的比较占用资源，后来工程师们发现一个线程其实是分为内核态和用户态的，并把这种用户态的线程起了个新的名字：协程，意思是轻量级的线程。再遇到IO阻塞的时候我们直接在用户态自己实现调度处理就好了，不需要麻烦低层操作系统去切换线程去调度。这样性能上升了一大截，因为一个进程占用的虚拟内存大约要4个G（32位操作系统），一个线程也需要4MB左右，而开一个协程就小的多了，Go中只需要几kb。

### 绑定关系
#### N:1

#### 1:1

#### M:N

### GMP模型
G：就是一个程序
M：系统线程
P：调度器